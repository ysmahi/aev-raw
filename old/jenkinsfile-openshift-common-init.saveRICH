#!/usr/bin/env groovy

// Constantes :

configDir = "repoConf"       // sous-repertoire de $WORKSPACE contenant le repo -conf
freeTierQuota = "dev-quotas" // si cet objet quota est present alors on est en free tier avec tres peu de ressource

ansiboldgreen="\u001B[1m\u001B[32m"; ansinormal="\u001B[0m"  // pour messages d'update en vert

// Variables globales, valorisees une fois par pipeline, declarer et laisser vide ici

repoSource = ""
repoConf = ""

processResult = ""

//---------------------------------------------------------------------------------------------------------------------------------
// PRINTBANNER : affiche une banniere bien visible dans la log du job sous Jenkins
//---------------------------------------------------------------------------------------------------------------------------------

def printBanner(String message) {  // pour marquer stages pipeline
    def line="==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--=="
    def boldblue="\u001B[1m\u001B[34m"; def normal="\u001B[0m";
    ansiColor('xterm') {
      println "${boldblue}${line}${normal}\n${boldblue}${line}${normal}\n${boldblue}==--==--${normal}\n${boldblue}==--==--   ${message} ${normal}\n${boldblue}==--==--${normal}\n${boldblue}${line}${normal}\n${boldblue}${line}${normal}"
    }
}
def printBanner2(String message) {  // pour BEGIN/END fonctions, en noir pas en bleu, et moins de lignes
    def line="==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--=="
    def bold="\u001B[1m"; def normal="\u001B[0m";
    ansiColor('xterm') {
      println "${bold}${line}${normal}\n${bold}==--==--${normal}\n${bold}==--==--   ${message} ${normal}\n${bold}==--==--${normal}\n${bold}${line}${normal}"
    }
}


//---------------------------------------------------------------------------------------------------------------------------------
// READCONFIG : charge le repertoire git de config dans $workspace/$configDir, et retourne le contenu du fichier de conf principal
//---------------------------------------------------------------------------------------------------------------------------------
def readConfig(String configFile) {

    if (repoSource=="") repoSource = sh(returnStdout: true, script: 'git config remote.origin.url').trim();
    if (repoSource[-4..-1] != ".git") repoSource="${repoSource}.git"
    println "repoSource = ${repoSource}"
    // Pour trouver le repo de configs env-dependantes, on ajoute -conf au nom du repo source
    if (repoConf=="") {
      repoConf = repoSource.take(repoSource.length()-4)+"-conf.git"
      dir("${configDir}") { // charge dans le soussrep du workspace defini par constante configDir
        git url : repoConf
      }
    }
    println "repoConf = ${repoConf}"

    configYAML = readYaml file: "${configDir}/${configFile}"

    println "Contenu du fichier de config ${configFile} :"; println configYAML

    return(configYAML)
}


//---------------------------------------------------------------------------------------------------------------------------------
// ISFREETIER : renvoie true si le projet courant est en free tier donc avec tres peu de ressources
//---------------------------------------------------------------------------------------------------------------------------------
Boolean isFreeTier() {
  return (openshift.selector("quota/${freeTierQuota}").count() == 1)
}


//---------------------------------------------------------------------------------------------------------------------------------
// SPLITIMAGETAG : renvoie un tableau de 3 Strings avec 1) image full name, 2) image name, 3) tag (quel que soit le format de la string entree)
// ex "docker-registry.default.svc:5000/azf-y6-springboot-cicd/nginx:dev" renvoie :
// [ "docker-registry.default.svc:5000/azf-y6-springboot-cicd/nginx", "nginx", ":dev" ]
// ex2 "nginx" renvoie :
// [ "nginx", "nginx", "" ]
//---------------------------------------------------------------------------------------------------------------------------------
String[] splitImageTag(String imageString) {
  //println "Called splitImageTag(${imageString})"
  String[] imageString_words = imageString.split('/')
  int imageString_words_size = imageString_words.size()
  String imageNameLeft = ""
  if (imageString_words_size > 1) {
    imageNameLeft = imageString_words[0]
    for (i = 1; i < imageString_words_size-1; i++) imageNameLeft = imageNameLeft+"/"+imageString_words[i]
  }
  String image = imageString_words.last()
  String[] image_words = image.split(':')
  String imageName = image_words[0]
  String imageFullName = imageName
  if (imageNameLeft != "") imageFullName = imageNameLeft+"/"+imageFullName
  String imageTag = ""
  if (image_words.size() == 2) imageTag = ":${image_words.last()}";
  //println "==> imageFullName=${imageFullName} imageName=${imageName} imageTag=${imageTag}"
  return [ imageFullName, imageName, imageTag ] as String[]
}


//---------------------------------------------------------------------------------------------------------------------------------
// UPDATEIFNEEDED : fait un oc patch si les valeurs parm3 (config) et parm4 (current) sont differents, applique le patch parm5
// parm1: type d'objet sur lequel le patch est applique (bc ou dc)
// parm2: nom du parametre de config yaml en jeu (uniquement pour affichage)
// parm3: valeur de ce parametre dans le config yaml
// parm4: valeur de l'equivalent dans l'objet courant (bc ou dc)
// parm5: patch a appliquer sur parm3 different de parm4 (normalement applique parm3)
//---------------------------------------------------------------------------------------------------------------------------------
def updateIfNeeded(String objType, String configKey, String configValue, String currentValue, String jsonPatch) {
  println "${appName}: ${envName}: ${configKey}  config=${configValue}"
  println "${appName}: ${envName}: ${configKey} current=${currentValue} (from ${objType})"
  if (configValue != currentValue) {
    println "${appName}: ${envName}: ==> patching the ${configKey} in ${objType} object..."
    def updated = openshift.raw('patch', objType, appName, '-p', jsonPatch)
    ansiColor('xterm') { echo "${ansiboldgreen}${updated.out}${ansinormal}" }
    updatesDone << "${openshift.project()}/${objType}/${appName} : updated ${configKey} from ${currentValue} to ${configValue}"
  }
  else println "${appName}: ${envName}: no ${objType} update needed for ${configKey}"
}


//---------------------------------------------------------------------------------------------------------------------------------
// SETENVVARSIFNEEDED : compare les envvars du dc en cours avec la section env_vars: de la config, fait un oc set env si différent
//---------------------------------------------------------------------------------------------------------------------------------
def setEnvVarsIfNeeded(def envVars) {
  def envVarP = ""
  
  // Construit envVarP au format KEY1="val1" KEY2="val2"...pour oc set env
  for (String envVar : envVars) {
    def envVarName = envVar.name
    def envVarValue = envVar.value
    if (envVarValue == null) envVarValue = "";
    if (envVarName[-1] == "-") envVarP0 = envVarName; // cas KEY- (enlever var)
    else envVarP0 = "${envVarName}=\"${envVarValue}\"";
    if (envVarP == "") envVarP = envVarP0;
    else envVarP = "${envVarP} ${envVarP0}";
  } // for envVar
  
  if (envVarP == "") return; // rien a faire
  
  println "${appName}: ${envName}: env_var : ${envVarP}"

  // Etat de l'objet DC actuel
  def varsBefore = openshift.raw('set','env', "dc/${appName}", '--list').out
  
  // l'option --list permet de simuler les variables apres un "oc set env", ordre alpha
  def testVarsAfter = openshift.raw('set', 'env', "dc/${appName}", '--list', envVarP).out
  println "${appName}: ${envName}: current env vars = ${varsBefore}"
  println "${appName}: ${envName}:  config env vars = ${testVarsAfter}"
  
  if (varsBefore == testVarsAfter) println "Config vars are identical to current, no update attempted";
  else {
    println "==> vars will change, updating object"
    def refreshed = openshift.raw('set', 'env', "dc/${appName}", envVarP)
    ansiColor('xterm') { echo "${ansiboldgreen}${refreshed.out}${ansinormal}" }
    updatesDone << "${openshift.project()} refreshed env_vars for ${appName} : ${envVarP}"
  }
}  

//---------------------------------------------------------------------------------------------------------------------------------
// SETPVIFNEEDED : cree un PVC, et un PV dans le DC, s'ils n'existent pas (et si d'autres volumes n'utilisent pas mountpoint, etc.) 
// 1er argument : objet yaml persistent_volume, 2eme argument 'CREATE' ou 'UPDATE' (si CREATE, rien ne doit exister)
//---------------------------------------------------------------------------------------------------------------------------------
def setPvIfNeeded(def pv, String creUpd) {
  if (pv == null) return; // rien a faire

  String pvClaimName = "${appName}-pvc"

  // On cherche si le PVC existe deja
  def pvc = openshift.selector("pvc/${pvClaimName}")
  
  if (pvc.count() == 0) {
    // On cree le PVC et le volume en meme temps, que ce soit en mode CREATE ou UPDATE
    def updated = openshift.raw('volume', "dc/${appName}",'--add', '--type=pvc', "--name=app-pv", 
      "--claim-size=${pvClaimSize}", "--claim-mode=${pvClaimMode}", "--claim-name=${pvClaimName}",
      "--mount-path=${pvMountPath}", "--containers=${appName}")
    ansiColor('xterm') { echo "${ansiboldgreen}${updated.out}${ansinormal}" }
    updatesDone << "${openshift.project()} added ${pvClaimMode} persistent volume of size ${pvClaimSize} mounted on ${pvMountPath} for app ${appName}"
    echo openshift.raw('label', 'pvc', "${pvClaimName}", "deploy=${appName}", "app=${appName}").out
    return
  }
  
  // On est ici si il existe deja un PVC, ce n'est compatible qu'avec l'UPDATE :

  assert creUpd == 'UPDATE' : "pvc/${pvClaimName} already exist, not compatible with CREATE" 
  
  // On est donc ici en UPDATE, on cherche à comparer config et current, tout doit matcher
  
  def pvcObj = pvc.object()
  def currentPvcSize = pvcObj.spec.resources.requests.storage
  def currentPvcMode = pvcObj.spec.accessModes[0]
  println "${appName}: ${envName}: current PVC ${pvClaimName} size=${currentPvcSize} mode=${currentPvcMode}"
  println "${appName}: ${envName}:  config PVC ${pvClaimName} size=${pvClaimSize} mode=${pvClaimMode}"
  assert (currentPvcSize == pvClaimSize && currentPvcMode == pvClaimMode) :
    "Config must be aligned with current PVC, updating PVC size/mode is not supported"
    
  // On est ici en UPDATE avec un PVC qui matche config size/mode, on va rechercher si le mount point matche

  // On parcourt les Volumes du DC a la recherche d'un volume pointant sur le PVC et qui matche le mountpoint
  def currentVolumes = dcObj.spec.template.spec.volumes
  Boolean foundOK = false
  for (def currentVolume : currentVolumes) {
    if (currentVolume.persistentVolumeClaim == null) continue; // on ne s'interesse qu'aux volumes persistants
    if (currentVolume.persistentVolumeClaim.claimName == pvClaimName) { // on a trouve le PVC dans le DC
      def volumeName = currentVolume.name // le volume name est ce qu'on va rechercher dans les VolumeMounts
      println "${appName}: ${envName}: found current DC volume name=${volumeName} that use PVC ${pvClaimName}"
      def currentVolumeMounts = dcObj.spec.template.spec.containers[0].volumeMounts
      println "currentVolumeMounts = ${currentVolumeMounts}"
      for (def currentVolumeMount : currentVolumeMounts) {
        if (currentVolumeMount.name == volumeName) {
          println "${appName}: ${envName}: found matching volumeMount ${volumeName} to path ${currentVolumeMount.mountPath}"
          assert currentVolumeMount.mountPath == pvMountPath : "volumeMount path does not match config mount_path=${pvMountPath}"
          foundOK = true
        }
      }
    }
  } // for currentVolume

  assert foundOK == true : 
    "Couldn't find any matching volumeMount for volume name ${volumeName} PVC ${pvClaimName}, in UPDATE mode you must align config with current DC"
  
  return // en UPDATE, on a trouve match complet config vs DC, donc on a rien a faire 

}

//---------------------------------------------------------------------------------------------------------------------------------
// PROCESSCONFIG : traite la config yaml (1er argument) en Create ou Update (2e argument)
// Creation/Update des objets de build et deploy des applications decrites dans la config
// Ne peut etre appele que par initAppObjects, updateAppObjects 
//---------------------------------------------------------------------------------------------------------------------------------
def processConfig(String configFile, String configOperation) {

  assert configOperation in ['Create', 'Update']

  printBanner2("processConfig file=${configFile} op=${configOperation}")
  
  updatesDone = []
  
  try {

    configYAML = readConfig(configFile)
    String clusterName = configYAML.cluster.name
    String projectRoot = configYAML.projectRoot.name

    openshift.withCluster(clusterName) {

      ixApp=0; int nbApp=configYAML.applications.size()
      println "Config ${configFile} : projectroot ${projectRoot} has ${nbApp} apps"

      for (String application : configYAML.applications) {
        ixApp++; appName = application.name
        printBanner("${configOperation} ${appName} (${ixApp}/${nbApp})")

        stage("${ixApp}/${nbApp} ${configOperation} ${appName} objects") {

          //------------------------
          // Partie BUILD 
          //------------------------

          printBanner2("${configOperation} ${appName} build objects")

          appType = application.app_type
          assert appType != null : "${appName}: app_type is mandatory"
          openshift.raw('get','template',"${appType}-azf-env",'-n','azf-cicd')
          println "${appName}: app_type=${appType}"


          openshift.withProject("${projectRoot}-cicd") {

            println "Using project ${openshift.project()}"

            builderTag = application.builder_tag
            if (builderTag != null) {
               assert appType != 'docker' : "${appName}: setting a builder_tag is incompatible with app_type docker"
               assert builderTag[0] == ':' : "${appName}: builder_tag must begin with a ':'"
            }
            else builderTag=":stable"
            println "${appName}: builder_tag=${builderTag}"

            if (appType=="docker") buildTemplateName = "docker-bin-azf-cicd"
            else buildTemplateName = "s2i-bin-azf-cicd"

            bc = openshift.selector("bc/${appName}")

            if (bc.count() == 0) { // c'est une creation

              println "${appName}: Creating BuildConfig and ImageStream objects..."
              def modelAppYaml = openshift.process( "azf-cicd//${buildTemplateName}", '--loglevel=1',
                "-p=APPLICATION_NAME=${appName}", "-p=APP_TYPE=${appType}", "-p=BUILDER_TAG=${builderTag}")
              def created = openshift.create(modelAppYaml)
              ansiColor('xterm') { echo "${ansiboldgreen}${created.out}${ansinormal}" }
              updatesDone << "${openshift.project()} build objects for ${appName} : created"

            } //fin create

            else { // bc existe deja 
           
              bcObj = bc.object()    // Evite multiples commandes oc get bc ensuite - pas de def car doit etre visible partout
              assert configOperation != 'Create' : "bc/${appName} already exist, can't use initAppObjects"


              println "${appName}: Checking build objects versus config..."
              currentAppType = bcObj.metadata.labels['app_type']
              String bc_image = bcObj.spec.strategy.sourceStrategy.from.name
              s = splitImageTag(bc_image)   // [0]=imgfullname [1]=imgname [2]=tag
              currentBuilderImage = s[0]; currentBuilderTag = s[2]
              println "${appName}: BuildConfig current image = ${bc_image}"
              assert (appType == currentAppType) : "app_type in YAML config must be identical to BuildConfig's app_type label (${currentAppType}"
              envName="cicd" // pour eviter de planter updateIfNeeded car l'utilise pour affichage
              updateIfNeeded("bc","builder_tag", builderTag, currentBuilderTag,
                '\'{"spec": {"strategy": {"sourceStrategy": {"from": {"name": "'+currentBuilderImage+builderTag+'"}}}}}\'')
            
            } //fin update

          } //withProject cicd

          //-------------------------
          // Partie DEPLOY
          //-------------------------

          for (String env : application.environments) {

            envName = env.name
            printBanner2("${configOperation} ${appName} ${envName} deploy objects")
            envProjName = "${projectRoot}-${envName}"

            // Autorise les serviceaccounts du namespace -<env> de puller images de -cicd
            openshift.withProject("${projectRoot}-cicd") {
              if (openshift.selector("rolebinding/system:image-puller-${envName}").count() ==0) {
                updated = openshift.raw('adm', 'policy', 'add-role-to-user', 'system:image-puller',
                 "system:serviceaccounts:${envProjName}","--rolebinding-name=system:image-puller-${envName}")
                ansiColor('xterm') { echo "${ansiboldgreen}${updated.out}${ansinormal}" }
                updatesDone << "${openshift.project()} added role system:image-puller to system:serviceaccounts:${envProjName}"
              }
            } // withProject cicd

            openshift.withProject("${envProjName}") {

              println "Using project ${openshift.project()}"

              assert isFreeTier() == false : "Project ${openshift.project()} is at free tier, this is not compatible with -env projects"

              imgTag = env.image_tag
              if (imgTag != null) assert imgTag[0] == ':' : "${appName}: ${envName}: image_tag must begin with a ':'";
              else imgTag = ":${envName}";
              println "${appName}: ${envName}: image_tag=${imgTag}"

              cpuReq = env.cpu_request
              cpuLim = env.cpu_limit
              assert env.mem_request == null : "${appName}: ${envName}: use memory_request, not mem_request"
              memReq = env.memory_request
              assert env.mem_request == null : "${appName}: ${envName}: use memory_limit, not mem_limit"
              memLim = env.memory_limit

              if (cpuReq == null) {
                if (cpuLim != null) cpuReq=cpuLim;
                else cpuReq = "200m";
              }
              if (cpuLim == null) cpuLim="1";
              if (memReq == null) {
                if (memLim != null) memReq=memLim;
                else memReq = "256Mi";
              }
              if (memLim == null) memLim="512Mi";

              println "${appName}: ${envName}: cpu_request=${cpuReq}"
              println "${appName}: ${envName}: cpu_limit=${cpuLim}"
              println "${appName}: ${envName}: memory_request=${memReq}"
              println "${appName}: ${envName}: memory_limit=${memLim}"

              initDelay = env.initial_delay
              if (initDelay == null) {
                switch (appType) {
                  case ~/mysql.*$/: initDelay=15; break;
                  case ~/nginx.*$/: initDelay=10; break;
                  case ~/openjdk.*$/: initDelay=30; break;
                  case ~/redis.*$/: initDelay=10; break;
                  case ~/tomcat.*$/: initDelay=40; break;
                  default: initDelay=30; break;
                }
              }
              println "${appName}: ${envName}: initial_delay=${initDelay}"

              replicaCount = env.replica_count
              if (replicaCount == null) replicaCount=1;
              println "${appName}: ${envName}: replica_count=${replicaCount}"

              deployStrategy = env.deploy_strategy
              if (deployStrategy == null) deployStrategy="Rolling";
              assert deployStrategy == "Rolling" || deployStrategy == "Recreate" : "${appName}: ${envName}: deploy_strategy must be Rolling or Recreate"
              println "${appName}: ${envName}: deploy_strategy=${deployStrategy}"

              if (env.persistent_volume != null) {
                pvClaimSize = env.persistent_volume.claim_size
                assert pvClaimSize != null : "${appName}: ${envName}: claim_size attribute mandatory for persistent_volume (e.g. 10Gi)" 
                pvClaimMode = env.persistent_volume.claim_mode
                assert pvClaimMode == 'ReadWriteOnce' || pvClaimMode == 'ReadWriteMany' || pvClaimMode == 'ReadOnlyMany' :
                  "${appName}: ${envName}: invalid or missing claim_mode attribute for persistent_volume (e.g. ReadWriteOnce)"
                pvMountPath = env.persistent_volume.mount_path 
                assert pvMountPath[0] == "/" && pvMountPath.size()>1 : 
                  "${appName}: ${envName}: invalid or missing mount_path attribute for persistent_volume (e.g. /data)"
                println "${appName}: ${envName}: persistent volume size=${pvClaimSize} mode=${pvClaimMode} path=${pvMountPath}"
              }

              dc = openshift.selector("dc/${appName}")

              if (dc.count() == 0) { // c'est une creation

                println "${appName}: ${envName}: Creating deployment objects..."
                def modelAppYaml = openshift.process( "azf-cicd//${appType}-azf-env", '--loglevel=1',
                  "-p=PROJECT_ROOT=${projectRoot}","-p=APPLICATION_NAME=${appName}", "-p=APP_ENV=${envName}", "-p=APP_TYPE=${appType}",
                  "-p=IMAGE_TAG=${imgTag}", "-p=CPU_LIMIT=${cpuLim}", "-p=MEM_LIMIT=${memLim}", "-p=CPU_REQUEST=${cpuReq}","-p=MEM_REQUEST=${memReq}",
                  "-p=REPLICA_COUNT=${replicaCount}", "-p=DEPLOY_STRATEGY=${deployStrategy}")
                created = openshift.create(modelAppYaml)
                ansiColor('xterm') { echo "${ansiboldgreen}${created.out}${ansinormal}" }
                updatesDone << "${openshift.project()} deploy objects for ${appName} : created"
                // les objets secret et configmap sont a creer vides et ne sont pas dans les templates
                echo openshift.raw('create', 'configmap',"${appName}-conf").out;
                echo openshift.raw('label', 'cm', "${appName}-conf", "deploy=${appName}", "app=${appName}").out
                echo openshift.raw('create', 'secret','generic',"${appName}-secret").out;
                echo openshift.raw('label', 'secrets', "${appName}-secret", "deploy=${appName}", "app=${appName}").out
                echo openshift.raw('secret', 'link', 'default', "${appName}-secret").out
                
                // env_vars (code commun avec update car on est obligé de faire oc set env dc/xxx)
                setEnvVarsIfNeeded(env.env_vars)

                // persistent_volume
                
                setPvIfNeeded(env.persistent_volume, 'CREATE')               
              
              } //fin create

              else { // dc existe deja
              
                dcObj = dc.object()   // Evite multiples commandes oc get dc ensuite - pas de def car doit etre visible partout 

                assert configOperation != 'Create' : "bc/${appName} already exists, can't use initAppObjects"
                println "${appName}: ${envName}: Checking deployment objects versus config..."
                // image_tag :
                dc_image = dcObj.spec.template.spec.containers[0].image
                println "${appName}: ${envName}: DeploymentConfig current image = ${dc_image}"
                s = splitImageTag(dc_image)   // [0]=imgfullname [1]=imgname [2]=tag
                currentDeployImage = s[0]; currentDeployTag = s[2]
                updateIfNeeded('dc', 'image_tag', imgTag, currentDeployTag,
                  '\'{"spec": {"template": {"spec": {"containers": [{"name": "'+appName+'","image": "'+currentDeployImage+imgTag+'"}]}}}}\'')

                //cpu/memory_limit/request :
                dc_resources = dcObj.spec.template.spec.containers[0].resources
                currentreq = dc_resources.requests
                if (currentreq != null) {
                  currentCR = dc_resources.requests.cpu
                  currentMR = dc_resources.requests.memory
                }
                else { currentCR = null; currentMR = null }
                currentlim = dc_resources.limits
                if (currentlim != null) {
                  currentCL = dc_resources.limits.cpu
                  currentML = dc_resources.limits.memory
                }
                else { currentCL = null; currentML = null }
                currentResources="CPUreq=${currentCR} CPUlim=${currentCL} MEMReq=${currentMR} MEMlim=${currentML}"
                configResources="CPUreq=${cpuReq} CPUlim=${cpuLim} MEMReq=${memReq} MEMlim=${memLim}"
                updateIfNeeded('dc', 'cpu&memory', configResources, currentResources,
                  '\'{"spec": {"template": {"spec": {"containers": [{"name": "'+appName+'","resources": {"requests": {"cpu": "'+cpuReq+'", "memory": "'+memReq+'"}, "limits": {"cpu": "'+cpuLim+'", "memory": "'+memLim+'"}}}]}}}}\'')

                // replica_count :
                currentReplicaCount = dcObj.spec.replicas   // forcer ensuite des strings...
                updateIfNeeded('dc', 'replica_count', "${replicaCount}", "${currentReplicaCount}", '\'{"spec": {"replicas": '+replicaCount+'}}\'')

                // deploy_strategy :
                currentDeployStrategy = dcObj.spec.strategy.type
                updateIfNeeded('dc', 'deploy_strategy', deployStrategy, currentDeployStrategy,
                  '\'{"spec": {"strategy": {"type": "'+deployStrategy+'"}}}\'')

                // env_vars :
                setEnvVarsIfNeeded(env.env_vars)

                // persistent_volume
                setPvIfNeeded(env.persistent_volume, 'UPDATE') 

              } //fin update

            } //withProject env

          } //for env
        } //stage

        //oc adm policy add-role-to-user edit system:serviceaccount:azf-cicd:jenkins

      } //for applications
    } //withCluster
    processResult = 'SUCCESS'
  }
  catch(e) {
    processResult = 'FAILURE'
    throw e
  }
  finally {
    if (processResult == 'SUCCESS' || updatesDone.size() > 0) {
     ansiColor('xterm') {
      println "${ansiboldgreen}UPDATES SUMMARY FOR THIS JOB :"
      println "${ansiboldgreen}------------------------------------------------------------------------"
      for (String update : updatesDone) {
         println "${ansiboldgreen}${update}"
      }
      if (updatesDone.size() == 0 && processResult == 'SUCCESS') println "${ansiboldgreen}No update needed!"
      println "${ansiboldgreen}------------------------------------------------------------------------${ansinormal}"
     }
    }
  }

} // processConfig()

//---------------------------------------------------------------------------------------------------------------------------------
// DELETEAPPOBJECTS : detruit les objets de build et deploy a partir de la config yaml 
//---------------------------------------------------------------------------------------------------------------------------------
def deleteAppObjects(String configFile, String oneAppName="") {
  timestamps {
        
    configYAML = readConfig(configFile)
    String clusterName = configYAML.cluster.name
    String projectRoot = configYAML.projectRoot.name

    openshift.withCluster(clusterName) {

      ixApp=0; int nbApp=configYAML.applications.size()
      println "Config ${configFile} : projectroot ${projectRoot} has ${nbApp} apps"

      for (String application : configYAML.applications) {
        ixApp++; appName = application.name
        printBanner("Deleting ${appName} (${ixApp}/${nbApp})")

        stage("${ixApp}/${nbApp} Delete ${appName} objects") {

          openshift.withProject("${projectRoot}-cicd") {

            println "Processing project ${openshift.project()}"

            def deleted = openshift.raw('delete', 'all', '--now', "-l app=${appName}")
            ansiColor('xterm') { echo "${ansiboldgreen}${deleted.out}${ansinormal}" } 

          } // withProject cicd

          for (String env : application.environments) {

            envName = env.name
            envProjName = "${projectRoot}-${envName}"

            openshift.withProject("${envProjName}") {

              println "Processing project ${openshift.project()}"
              def deleted = openshift.raw('delete', 'all,cm,secret,pvc', '--now', "-l app=${appName}")
              ansiColor('xterm') { echo "${ansiboldgreen}${deleted.out}${ansinormal}" } 

            } // withProject env

          } // for env

        } // stage

      } // for application

    } // withCluster
   
  } // timestamps 
}




//---------------------------------------------------------------------------------------------------------------------------------
// INITAPPOBJECTS : cree les objets de build et deploy a partir de la config yaml et des templates
//---------------------------------------------------------------------------------------------------------------------------------
def initAppObjects(String configFile, String oneAppName="") {
  timestamps {
    processConfig(configFile, 'Create')   // 2e parm Create : refuser si objets existent deja
  } 
}

//---------------------------------------------------------------------------------------------------------------------------------
// UPDATEAPPOBJECTS : patche les objets de build et deploy a partir de la config yaml et des objets actuels (si different)
//---------------------------------------------------------------------------------------------------------------------------------
def updateAppObjects(String configFile, String oneAppName="") {
  timestamps {
    processConfig(configFile, 'Update')   
  } 
}



return this
