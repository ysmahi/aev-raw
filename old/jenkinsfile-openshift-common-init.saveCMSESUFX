#!/usr/bin/env groovy

// J'ai renonce car oc set volume suivi d'un apply genere toujours un updated,
// meme si tous les champs egaux y compris nom de l'appconf...

// Constantes :

configDir = "repoConf"       // sous-repertoire de $WORKSPACE contenant le repo -conf
tempDir = "_octemp_"             // sous-repertoire de $WORKSPACE contenant des fichiers a ne pas conserver
freeTierQuota = "dev-quotas" // si cet objet quota est present alors on est en free tier avec tres peu de ressource
defaultTemplatesRepo = 'http://bitbucket.agf.fr/projects/Y6/repos/y6-ocp-azf-templates'  // si template_file: vide

ansiboldgreen="\u001B[1m\u001B[32m"; ansinormal="\u001B[0m"  // pour messages d'update en vert
ansiboldred="\u001B[1m\u001B[31m"  // pour messages d'update en rouge

// Variables globales, valorisees une fois par pipeline, declarer et laisser vide ici

repoSource = ""
repoConf = ""

jobResult = ""

//---------------------------------------------------------------------------------------------------------------------------------
// PRINTBANNER : affiche une banniere bien visible dans la log du job sous Jenkins
//---------------------------------------------------------------------------------------------------------------------------------

def printBanner(String message) {  // pour marquer stages pipeline
    def line="==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--=="
    def boldblue="\u001B[1m\u001B[34m"; def normal="\u001B[0m";
    ansiColor('xterm') {
      println "${boldblue}${line}${normal}\n${boldblue}${line}${normal}\n${boldblue}==--==--${normal}\n${boldblue}==--==--   ${message} ${normal}\n${boldblue}==--==--${normal}\n${boldblue}${line}${normal}\n${boldblue}${line}${normal}"
    }
}
def printBanner2(String message) {  // pour BEGIN/END fonctions, en noir pas en bleu, et moins de lignes
    def line="==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--=="
    def bold="\u001B[1m"; def normal="\u001B[0m";
    ansiColor('xterm') {
      println "${bold}${line}${normal}\n${bold}==--==--${normal}\n${bold}==--==--   ${message} ${normal}\n${bold}==--==--${normal}\n${bold}${line}${normal}"
    }
}


//---------------------------------------------------------------------------------------------------------------------------------
// READCONFIG : charge le repertoire git de config dans $workspace/$configDir, et retourne le contenu du fichier de conf principal
//---------------------------------------------------------------------------------------------------------------------------------
def readConfig(String configFile) {

    if (repoSource=="") repoSource = sh(returnStdout: true, script: 'git config remote.origin.url').trim();
    if (repoSource[-4..-1] != ".git") repoSource="${repoSource}.git"
    println "repoSource = ${repoSource}"
    // Pour trouver le repo de configs env-dependantes, on ajoute -conf au nom du repo source
    if (repoConf=="") {
      repoConf = repoSource.take(repoSource.length()-4)+"-conf.git"
      dir("${configDir}") { // charge dans le soussrep du workspace defini par constante configDir
        git url : repoConf
      }
    }
    println "repoConf = ${repoConf}"

    configYAML = readYaml file: "${configDir}/${configFile}"

    println "Contenu du fichier de config ${configFile} :"; println configYAML

    return(configYAML)
}


//---------------------------------------------------------------------------------------------------------------------------------
// ISFREETIER : renvoie true si le projet courant est en free tier donc avec tres peu de ressources
//---------------------------------------------------------------------------------------------------------------------------------
Boolean isFreeTier() {
  return (openshift.selector("quota/${freeTierQuota}").count() == 1)
}

//---------------------------------------------------------------------------------------------------------------------------------
// GETCMSENAMES : si APPCONF_SUFFIX et/ou APPSECRET_SUFFIX font partie des parametres du templateFile (arg)
// et si dans le DC courant on trouve les volumes appconf/appsecret avec un nom modifie par pipelines
// alors renvoie '-p=APPCONF_SUFFIX=<suffixecm> -p=APPSECRET_SUFFIX=<suffixese> avec les suffixes du DC courant
// sinon renvoie une chaine vide. 
// Cela sert a garder le meme nom d'objet appconf/secret lors de l'apply sur DC existant s'il les a chang√©s, 
// en forcant le parametre APPCONF/SECRET_SUFFIX aux valeurs actuelles du DC lors de l'oc process.
// Afin d'eviter de voir l'objet DC toujours "updated" par l'apply alors qu'il n'y a a pas de changement.  
//---------------------------------------------------------------------------------------------------------------------------------
def getCmSeNames(String templateFile) {
  def i = 0  // index local
  def cmseParms = ''     // sera rempli avec chaine retournee
  def cmSufx = ''
  def seSufx = ''

  def dcSel = openshift.selector("dc/${appName}")
  if (! dcSel.exists()) return('') // pas la peine si DC n'existe pas deja
  
  // Cherche nom actuel du configmap du DC volume appconf, idem appsecret 
  // puis verifie que le format de nom correspond a un objet deja incremente dans les pipelines
  def dcVols = dcSel.object().spec.template.spec.volumes
  for (i=0; i < dcVols.size(); i++) {
    def dcVol = dcVols[i]
    if (dcVol.name == "appconf") {
      println "dc/${appName} volume ${dcVol.name} uses configmap ${dcVol.configMap.name}"
      def cmw = dcVol.configMap.name.split('-')
      // on controle que c'est bien au format ${appName}-conf-x, on prend alors le x
      if (cmw.size() == 3 && cmw[0] == appName && cmw[1] == 'conf') {
        cmSufx = '-'+cmw[2]; println "....which could be eligible for APPCONF_SUFFIX=${cmSufx}"
      }
    }
    else if (dcVol.name == "appsecret") {
      println "dc/${appName} volume ${dcVol.name} uses secret ${dcVol.secret.secretName}"
      def sew = dcVol.secret.secretName.split('-') 
      // on controle que c'est bien au format ${appName}-secret-y, on prend alors le y 
      if (sew.size() == 3 && sew[0] == appName && sew[1] == 'secret') {
        seSufx = '-'+sew[2]; println "....which could be eligible for APPSECRET_SUFFIX=${seSufx}"
      }
    }
  }

  if (cmSufx+seSufx == "") return('')  // pas la peine si rien trouve au bon format dans le DC

  def deployTemplateParms = openshift.raw('process', "-f ${deployTemplateFile}", '--parameters')
  //println "Template parms = ${deployTemplateParms.out}"
  tempFile = "${tempDir}/template_possible_parms_${appName}.out"
  writeFile file: tempFile, text: deployTemplateParms.out
  if (cmSufx != "") {
    if (sh(script: "grep -q '^APPCONF_SUFFIX ' ${tempFile}", returnStatus:true) == 0) 
      cmseParms="-p=APPCONF_SUFFIX=${cmSufx}";
    else println "WARNING : can't find APPCONF_SUFFIX in template definition to override default" 
  } 
  if (seSufx != "") {
    if (sh(script: "grep -q '^APPSECRET_SUFFIX ' ${tempFile}", returnStatus:true) == 0) 
      cmseParms="${cmseParms} -p=APPSECRET_SUFFIX=${seSufx}";
    else println "WARNING : can't find APPSECRET_SUFFIX in template definition to override default"
  }

  return(cmseParms)
}

//---------------------------------------------------------------------------------------------------------------------------------
// PROCESSCONFIG : traite la config yaml (1er argument) en Create ou Update (2e argument)
// Creation/Update des objets de build et deploy des applications decrites dans la config
// Ne peut etre appele que par initAppObjects, updateAppObjects 
//---------------------------------------------------------------------------------------------------------------------------------
def processConfig(String configFile, String configOperation) {

  assert configOperation in ['Create', 'Update']

  println "=========> processConfig file=${configFile} op=${configOperation}"

  updatesDone = []

  try {
  
    sh(script: "mkdir -vp --mode=755 ${tempDir}")  // pour fichiers temporaires 
    
    configYAML = readConfig(configFile)
    String clusterName = configYAML.cluster.name
    String projectRoot = configYAML.projectRoot.name

    openshift.withCluster(clusterName) {

      ixApp=0; int nbApp=configYAML.applications.size()
      println "Config ${configFile} : projectroot ${projectRoot} has ${nbApp} apps"

      for (String application : configYAML.applications) {
        ixApp++; appName = application.name
        printBanner("${configOperation} ${appName} (${ixApp}/${nbApp})")

        stage("${ixApp}/${nbApp} ${configOperation} ${appName} objects") {

          printBanner2("${configOperation} ${appName} build objects")

          appType = application.app_type
          assert appType != null : "${appName}: app_type is mandatory (can be empty, though)"
          println "${appName}: app_type=${appType}"

          //------------------------
          // Partie BUILD 
          //------------------------        

          openshift.withProject("${projectRoot}-cicd") {

            println "Using project ${openshift.project()}"

            // Recuperation du nom de fichier template de BUILD

            buildTemplateName = application.build_template
            if (buildTemplateName == null || buildTemplatename == "") { 
              if (appType=="docker") buildTemplateName = "docker-bin-azf-cicd"
              else buildTemplateName = "s2i-bin-azf-cicd"
              buildTemplateFile = "${defaultTemplatesRepo}/raw/build/${buildTemplateName}.yaml"
            }
            else { 
              println "${appName}: build_template=${buildTemplateName}"
              buildTemplateFile = configDir+'/'+buildTemplateName
            }

            // Recuperation des parametres pour le template de BUILD

            String parmList = ""
            println "${appName}: cicd: parameters=${application.parameters}"
            if (application.parameters != null) {
              application.parameters.each {
                parmList = "${parmList} -p=${it.key}=\"${it.value}\""
              }
            }

            // Appel au template pour create ou apply

            println "${appName}: cicd: oc process template = ${buildTemplateFile}"
            println "${appName}: cicd:            parmList = ${parmList}"

            //def result = openshift.raw('process', "azf-cicd//${buildTemplateName}",
            def result = openshift.raw('process', "-f ${buildTemplateFile}",
              "-p=APPLICATION_NAME=${appName}", "-p=APP_TYPE=${appType}", parmList)
            println "Process template result status = ${result.status}"
            jsonFile = "${tempDir}/process_${appName}_cicd.out"
            writeFile file: jsonFile, text: result.out
            
            println "${appName}: ${configOperation} build objects..."
            if (configOperation == 'Create') {
              result = openshift.raw('create', '-f', jsonFile, '--save-config')
            }
            else {
              result = openshift.raw('apply', '-f', jsonFile)
            }
            ansiColor('xterm') { echo "${ansiboldgreen}${result.out}${ansinormal}" }
            updatesDone << "${openshift.project()} ${result.out}"
            
            // Autre maniere : avantage peut modifier objet entre process et apply, inconv : always upd
            //    def modelAppYaml = openshift.process( "azf-cicd//${buildTemplateName}", 
            //      "-p=APPLICATION_NAME=${appName}", "-p=APP_TYPE=${appType}", parmList)
            //    if (configOperation == 'Create') created = openshift.create(modelAppYaml);
            //    else created = openshift.apply(modelAppYaml);
            //   ansiColor('xterm') { echo "${ansiboldgreen}${created.out}${ansinormal}" }

          } //withProject cicd

          //-------------------------
          // Partie DEPLOY
          //-------------------------

          // Recuperation du nom de fichier template de DEPLOY

          deployTemplateName = application.deploy_template
          if (deployTemplateName == null || deployTemplateName == "") { 
            deployTemplateName = "${appType}-azf-env"
            deployTemplateFile = "${defaultTemplatesRepo}/raw/deploy/${deployTemplateName}.yaml"
          }
          else {
            println "${appName}: deploy_template=${deployTemplateName}"
            deployTemplateFile = configDir+'/'+deployTemplateName
          }

          for (String env : application.environments) {

            envName = env.name
            printBanner2("${configOperation} ${appName} ${envName} deploy objects")
            envProjName = "${projectRoot}-${envName}"

            // Autorise les serviceaccounts du namespace -<env> de puller images de -cicd
            openshift.withProject("${projectRoot}-cicd") {
              if (openshift.selector("rolebinding/system:image-puller-${envName}").count() ==0) {
                updated = openshift.raw('adm', 'policy', 'add-role-to-user', 'system:image-puller',
                  "system:serviceaccounts:${envProjName}","--rolebinding-name=system:image-puller-${envName}")
                ansiColor('xterm') { echo "${ansiboldgreen}${updated.out}${ansinormal}" }
                updatesDone << "${openshift.project()} ${updated.out}"
              }
            } // withProject cicd

            openshift.withProject("${envProjName}") {

              println "Using project ${openshift.project()}"

              assert isFreeTier() == false : "Project ${openshift.project()} is at free tier, this is not compatible with -env projects"

              // Recuperation des parametres pour le template

              String parmList = ""
              println "${appName}: ${envName}: parameters=${env.parameters}"
              if (env.parameters != null) {
                env.parameters.each {
                  parmList = "${parmList} -p=${it.key}=\"${it.value}\""
                }
              }

              // Ajout des eventuels APPCONF_SUFFIX et APPSECRET_SUFFIX, le cas echeant
              def CmSeParms = getCmSeNames(deployTemplateFile)
              if (CmSeParms != "") parmList = "${parmList} ${CmSeParms}" 

              println "${appName}: ${envName}: oc process template = ${deployTemplateFile}"
              println "${appName}: ${envName}:            parmList = ${parmList}"

              //def result = openshift.raw('process', "azf-cicd//${buildTemplateName}",
              def result = openshift.raw('process', "-f ${deployTemplateFile}",
                "-p=PROJECT_ROOT=${projectRoot}", "-p=APPLICATION_NAME=${appName}", "-p=APP_ENV=${envName}", 
                "-p=APP_TYPE=${appType}", parmList)

              println "Process template result status = ${result.status}"
              jsonFile = "${tempDir}/process_${appName}_${envName}.out"
              writeFile file: jsonFile, text: result.out
                          
              // Note: si appconf a deja tourne (-conf-n) il y aura toujours update car vo, revient a -conf
              println "${appName}: ${configOperation} deploy objects..."
              if (configOperation == 'Create') {
                result = openshift.raw('create', '-f', jsonFile, '--save-config')
              }
              else {
                result = openshift.raw('apply', '-f', jsonFile)
              }
              ansiColor('xterm') { echo "${ansiboldgreen}${result.out}${ansinormal}" }
              updatesDone << "${openshift.project()} ${result.out}"


            } //withProject env

          } //for env
        } //stage

        //oc adm policy add-role-to-user edit system:serviceaccount:azf-cicd:jenkins

      } //for applications
    } //withCluster

    jobResult = 'SUCCESS'
  } // try
  catch(e) {
    jobResult = 'FAILURE'
    throw e
  }
  finally {
    if (jobResult == 'SUCCESS' || updatesDone.size() > 0) {
     ansiColor('xterm') {
      if (jobResult == 'FAILURE') ansicolored = ansiboldred
      else ansicolored = ansiboldgreen 
      println "${ansicolored}UPDATES SUMMARY FOR THIS JOB :"
      println "${ansicolored}------------------------------------------------------------------------"
      for (String update : updatesDone) {
         println "${ansicolored}${update}"
      }
      if (updatesDone.size() == 0 && jobResult == 'SUCCESS') println "${ansicolored}No update needed!"
      if (updatesDone.size() >= 1 && jobResult == 'FAILURE') println "${ansicolored}==> then FAILURE"
      println "${ansicolored}------------------------------------------------------------------------${ansinormal}"
     }
    }
  }

} // processConfig()

//---------------------------------------------------------------------------------------------------------------------------------
// DELETEAPPOBJECTS : detruit les objets de build et deploy a partir de la config yaml 
//---------------------------------------------------------------------------------------------------------------------------------
def deleteAppObjects(String configFile, String oneAppName="") {
  timestamps {
        
    configYAML = readConfig(configFile)
    String clusterName = configYAML.cluster.name
    String projectRoot = configYAML.projectRoot.name

    openshift.withCluster(clusterName) {

      ixApp=0; int nbApp=configYAML.applications.size()
      println "Config ${configFile} : projectroot ${projectRoot} has ${nbApp} apps"

      for (String application : configYAML.applications) {
        ixApp++; appName = application.name
        printBanner("Deleting ${appName} (${ixApp}/${nbApp})")

        stage("${ixApp}/${nbApp} Delete ${appName} objects") {

          openshift.withProject("${projectRoot}-cicd") {

            println "Processing project ${openshift.project()}"

            def deleted = openshift.raw('delete', 'all', '--now', "-l app=${appName}")
            ansiColor('xterm') { echo "${ansiboldgreen}${deleted.out}${ansinormal}" } 

          } // withProject cicd

          for (String env : application.environments) {

            envName = env.name
            envProjName = "${projectRoot}-${envName}"

            openshift.withProject("${envProjName}") {

              println "Processing project ${openshift.project()}"
              def deleted = openshift.raw('delete', 'all,cm,secret,pvc', '--now', "-l app=${appName}")
              ansiColor('xterm') { echo "${ansiboldgreen}${deleted.out}${ansinormal}" } 

            } // withProject env

          } // for env

        } // stage

      } // for application

    } // withCluster
   
  } // timestamps 
}




//---------------------------------------------------------------------------------------------------------------------------------
// INITAPPOBJECTS : cree les objets de build et deploy a partir de la config yaml et des templates
//---------------------------------------------------------------------------------------------------------------------------------
def initAppObjects(String configFile, String oneAppName="") {
  timestamps {
    processConfig(configFile, 'Create')   // 2e parm Create : refuser si objets existent deja
  } 
}

//---------------------------------------------------------------------------------------------------------------------------------
// UPDATEAPPOBJECTS : patche les objets de build et deploy a partir de la config yaml et des objets actuels (si different)
//---------------------------------------------------------------------------------------------------------------------------------
def updateAppObjects(String configFile, String oneAppName="") {
  timestamps {
    processConfig(configFile, 'Update')   
  } 
}



return this
